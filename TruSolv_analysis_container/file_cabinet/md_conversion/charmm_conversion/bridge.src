
!------------------------------------------------!
subroutine PACKAGE_HELLO()
 use sa_analysis
 implicit none

write(*,*)"SA_Analysis Initilized"
frame_count=0

end subroutine

!------------------------------------------------!

!------------------------------------------------!
subroutine INITILIZE_GRID_SPACE()
!------------------------------------------------!
  use sa_analysis
  use coord

  implicit none

  integer :: k,kk,j,jj,xx,yy,zz,modside,point_x,point_y,point_z

  !Find Bounds of Selection
  minnx=999
  minny=999
  minnz=999
  maxxx=-999
  maxxy=-999
  maxxz=-999

  do k=1,NatomA
       kk=ListA(k)

       point_x=INT((floor(X(kk))))
       if(point_x .LT. minnx)then
          minnx=point_x
       endif
       if(point_x .GT. maxxx)then
          maxxx=point_x
       endif

       point_y=INT((floor(Y(kk))))
       if(point_y .LT. minny)then
          minny=point_y
       endif
       if(point_y .GT. maxxy)then
          maxxy=point_y
       endif

       point_z=INT((floor(Z(kk))))
       if(point_z .LT. minnz)then
          minnz=point_z
       endif
       if(point_z .GT. maxxz)then
          maxxz=point_z
       endif
  enddo

  !Find Longest Side
  sidex=(maxxx-minnx)+1
  sidey=(maxxy-minny)+1
  sidez=(maxxz-minnz)+1

  !Print Map
  counter=0
  OPEN(1745,FILE='map.dat')
  do xx=minnx,maxxx
     do yy=minny,maxxy
        do zz=minnz,maxxz
           write(1745,'(I8,2x,I8,2x,I8)'),xx,yy,zz
           flush(1745)
           counter=counter+1
        enddo
     enddo
  enddo

num_points=counter

end subroutine


!------------------------------------------------!
subroutine INITIILZE_TYPE_SELECTIONS()
!------------------------------------------------!
  use sa_analysis
  use psf
  use image

  implicit none

  integer :: i

  ALLOCATE(type_array(1:natim))
  type_array(:)=0

  do i=1,Natim
   if(atype(i) == 'O')then
      type_array(i)=1
   endif
   if(atype(i) == 'N')then
      type_array(i)=1
   endif
   if(atype(i) == 'OG')then
      type_array(i)=1
   endif
   if(atype(i) == 'OG1')then
      type_array(i)=1
   endif
   if(atype(i) == 'OH')then
      type_array(i)=1
   endif
   if(atype(i) == 'OD1')then
      type_array(i)=1
   endif
   if(atype(i) == 'OD2')then
      type_array(i)=1
   endif
   if(atype(i) == 'OE1')then
      type_array(i)=1
   endif
   if(atype(i) == 'OE2')then
      type_array(i)=1
   endif
   if(atype(i) == 'NE1')then
      type_array(i)=1
   endif
   if(atype(i) == 'ND2')then
      type_array(i)=1
   endif
   if(atype(i) == 'OE1')then
      type_array(i)=1
   endif
   if(atype(i) == 'NE2')then
      type_array(i)=1
   endif
   if(atype(i) == 'NZ')then
      type_array(i)=1
   endif
   if(atype(i) == 'NE')then
      type_array(i)=1
   endif
   if(atype(i) == 'NH1')then
      type_array(i)=1
   endif
   if(atype(i) == 'NH2')then
      type_array(i)=1
   endif
   if(atype(i) == 'OH2')then
      type_array(i)=1
   endif
   if(atype(i) == 'ND1')then
      type_array(i)=1
   endif

enddo

end subroutine

!------------------------------------------------!
 subroutine DESELECT_TYPES()
!------------------------------------------------!
 use sa_analysis

 implicit none

 DEALLOCATE (type_array)

end subroutine

!------------------------------------------------!
 subroutine COUNT_HYDROGEN_BONDS()
!------------------------------------------------!
  use sa_analysis
  use coord
  use psf
  use image

  implicit none

  integer :: xx,yy,zz,num_protons,curr_count,n_of_grid

  ALLOCATE(grid_array(1:num_points))
  grid_array(:)=0

  frame_count=frame_count+1
  write(*,*)"Processing Frame  ",frame_count

  if(frame_count .EQ. 1)then
     num_comparison=natoma
     ALLOCATE(count_totals(1:num_points))
     count_totals(:)=0
     OPEN(999,FILE='hb_count_matrix.dat')
     OPEN(998,FILE='hb_count_totals.dat')
     OPEN(125,FILE='hb_avg.dat')
  endif

  curr_count=0

!--------------------------------!

!~~~~~~~~~~~~~Serine~~~~~~~~~~~~~!
  if(NatomB .GT. 0)then
     num_protons=1
     call water_wrapper(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array,NatomA,ListA,NatomB,ListB,type_array,natim,num_protons,curr_count)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~Threonine~~~~~~~~~~~!
  if(NatomC .GT. 0)then
     num_protons=1
     call water_wrapper(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array,NatomA,ListA,NatomC,ListC,type_array,natim,num_protons,curr_count)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~Tyrosine~~~~~~~~~~~~!
  if(NatomD .GT. 0)then
     num_protons=1
     call water_wrapper(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array,NatomA,ListA,NatomD,ListD,type_array,natim,num_protons,curr_count)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~Tryptophan~~~~~~~~~~~~~~!
  if(NatomE .GT. 0)then
     num_protons=1
     call water_wrapper(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array,NatomA,ListA,NatomE,ListE,type_array,natim,num_protons,curr_count)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~Arginine~~~~~~~~~~~~~!
  if(NatomF .GT. 0)then
     num_protons=1
     call water_wrapper(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array,NatomA,ListA,NatomF,ListF,type_array,natim,num_protons,curr_count)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~~HSD~~~~~~~~~~~~~~~~!
  if(NatomLL .GT. 0)then
     num_protons=1
     call water_wrapper(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array,NatomA,ListA,NatomLL,ListL,type_array,natim,num_protons,curr_count)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~~HSE~~~~~~~~~~~~~~~~!
  if(NatomM .GT. 0)then
     num_protons=1
     call water_wrapper(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array,NatomA,ListA,NatomM,ListM,type_array,natim,num_protons,curr_count)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~~H2O~~~~~~~~~~~~~~~~!
  if(NatomG .GT. 0)then
     num_protons=2
     call water_wrapper(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array,NatomA,ListA,NatomG,ListG,type_array,natim,num_protons,curr_count)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~Asparagine~~~~~~~~~~~~!
  if(NatomH .GT. 0)then
     num_protons=2
     call water_wrapper(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array,NatomA,ListA,NatomH,ListH,type_array,natim,num_protons,curr_count)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~Glutamine~~~~~~~~~~~~~!
  if(NatomI .GT. 0)then
     num_protons=2
     call water_wrapper(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array,NatomA,ListA,NatomI,ListI,type_array,natim,num_protons,curr_count)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~Arginine Terminal NH~~~~~~~!
  if(NatomJ .GT. 0)then
     num_protons=2
     call water_wrapper(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array,NatomA,ListA,NatomJ,ListJ,type_array,natim,num_protons,curr_count)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~Lysine~~~~~~~~~~~~~~!
  if(NatomK .GT. 0)then
     num_protons=3
     call water_wrapper(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array,NatomA,ListA,NatomK,ListK,type_array,natim,num_protons,curr_count)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~Backbone NH~~~~~~~~~~~~!
  if(NatomN .GT. 0)then
     num_protons=1
     call water_wrapper(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array,NatomA,ListA,NatomN,ListN,type_array,natim,num_protons,curr_count)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

  !Write and Update HB Counts
  do xx=minnx,maxxx
     do yy=minny,maxxy
        do zz=minnz,maxxz
           n_of_grid=(xx-minnx)+((yy-minny)*sidex)+((zz-minnz)*sidex*sidey)+1
           count_totals(n_of_grid)=count_totals(n_of_grid)+grid_array(n_of_grid)
           write(999,'(I8,2x,G21.14)'),frame_count,grid_array(n_of_grid)
           call flush(999)
           if(mod(frame_count,10) .EQ. 0)then
              write(998,'(I8,2x,G21.14)'),frame_count,count_totals(n_of_grid)
              call flush(998)
           endif
        enddo
     enddo
  enddo

 !Write Average
 write(125,'(I8,2x,G21.14)'),frame_count,((curr_count+0.0)/(num_comparison+0.0))
 call flush(125)

!--------------------------------!

 DEALLOCATE(grid_array)

end subroutine

!------------------------------------------------!
 subroutine COUNT_HYDROGEN_BONDS_2()
!------------------------------------------------!
  use sa_analysis
  use coord
  use psf
  use image

  implicit none

  integer :: xx,yy,zz,num_protons,curr_count,n_of_grid

  ALLOCATE(grid_array2(1:num_points))
  grid_array2(:)=0

  frame_count=frame_count+1
  write(*,*)"Processing Frame  ",frame_count

  if(frame_count .EQ. 1)then
     num_comparison=natoma
     ALLOCATE(count_totals2(1:num_points))
     count_totals2(:)=0
     OPEN(999,FILE='hb_count_matrix.dat')
     OPEN(998,FILE='hb_count_totals.dat')
     OPEN(125,FILE='hb_avg.dat')
  endif

  curr_count=0

!--------------------------------!

!~~~~~~~~~~~~~Serine~~~~~~~~~~~~~!
  if(NatomB .GT. 0)then
     num_protons=1
     call water_wrapper_3(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array2,NatomA,ListA,NatomB,ListB,type_array,natim,num_protons,curr_count,radius_array)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~Threonine~~~~~~~~~~~!
  if(NatomC .GT. 0)then
     num_protons=1
     call water_wrapper_3(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array2,NatomA,ListA,NatomC,ListC,type_array,natim,num_protons,curr_count,radius_array)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~Tyrosine~~~~~~~~~~~~!
 if(NatomD .GT. 0)then
     num_protons=1
     call water_wrapper_3(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array2,NatomA,ListA,NatomD,ListD,type_array,natim,num_protons,curr_count,radius_array)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~Tryptophan~~~~~~~~~~~~~~!
  if(NatomE .GT. 0)then
     num_protons=1
     call water_wrapper_3(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array2,NatomA,ListA,NatomE,ListE,type_array,natim,num_protons,curr_count,radius_array)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~Arginine~~~~~~~~~~~~~!
  if(NatomF .GT. 0)then
     num_protons=1
     call water_wrapper_3(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array2,NatomA,ListA,NatomF,ListF,type_array,natim,num_protons,curr_count,radius_array)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~~HSD~~~~~~~~~~~~~~~~!
  if(NatomLL .GT. 0)then
     num_protons=1
     call water_wrapper_3(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array2,NatomA,ListA,NatomLL,ListL,type_array,natim,num_protons,curr_count,radius_array)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~~HSE~~~~~~~~~~~~~~~~!
  if(NatomM .GT. 0)then
     num_protons=1
     call water_wrapper_3(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array2,NatomA,ListA,NatomM,ListM,type_array,natim,num_protons,curr_count,radius_array)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!
!~~~~~~~~~~~~~H2O~~~~~~~~~~~~~~~~!
  if(NatomG .GT. 0)then
     num_protons=2
     call water_wrapper_3(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array2,NatomA,ListA,NatomG,ListG,type_array,natim,num_protons,curr_count,radius_array)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~Asparagine~~~~~~~~~~~~!
  if(NatomH .GT. 0)then
     num_protons=2
     call water_wrapper_3(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array2,NatomA,ListA,NatomH,ListH,type_array,natim,num_protons,curr_count,radius_array)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~Glutamine~~~~~~~~~~~~~!
  if(NatomI .GT. 0)then
     num_protons=2
     call water_wrapper_3(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array2,NatomA,ListA,NatomI,ListI,type_array,natim,num_protons,curr_count,radius_array)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~Arginine Terminal NH~~~~~~~!
  if(NatomJ .GT. 0)then
     num_protons=2
     call water_wrapper_3(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array2,NatomA,ListA,NatomJ,ListJ,type_array,natim,num_protons,curr_count,radius_array)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~Lysine~~~~~~~~~~~~~~!
  if(NatomK .GT. 0)then
     num_protons=3
     call water_wrapper_3(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array2,NatomA,ListA,NatomK,ListK,type_array,natim,num_protons,curr_count,radius_array)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~Backbone NH~~~~~~~~~~~~!
  if(NatomN .GT. 0)then
     num_protons=1
     call water_wrapper_3(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array2,NatomA,ListA,NatomN,ListN,type_array,natim,num_protons,curr_count,radius_array)
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

  !Write and Update HB Counts
  do xx=minnx,maxxx
     do yy=minny,maxxy
        do zz=minnz,maxxz
           n_of_grid=(xx-minnx)+((yy-minny)*sidex)+((zz-minnz)*sidex*sidey)+1
           count_totals2(n_of_grid)=count_totals2(n_of_grid)+grid_array2(n_of_grid)
           write(999,'(I8,2x,G21.14)'),frame_count,grid_array2(n_of_grid)
           call flush(999)
           if(mod(frame_count,10) .EQ. 0)then
              write(998,'(I8,2x,G21.14)'),frame_count,count_totals2(n_of_grid)
              call flush(998)
           endif
        enddo
     enddo
  enddo

 !Write Average
 write(125,'(I8,2x,G21.14)'),frame_count,((curr_count+0.0)/(num_comparison+0.0))
 call flush(125)

!--------------------------------!

 DEALLOCATE(grid_array2)

end subroutine

!------------------------------------------------!
 subroutine COUNT_HYDROGEN_BONDS_3()
!------------------------------------------------!
  use sa_analysis
  use coord
  use psf
  use image

  implicit none

  integer :: k,kk,j,jj,q,xx,yy,zz,rx,ry,rz,num_protons,curr_count,n_of_grid
  real(chm_real) ::curr_dist,dist_a

  ALLOCATE(grid_array2(1:num_points))
  grid_array2(:)=0.0

  frame_count=frame_count+1
  write(*,*)"Processing Frame  ",frame_count

  if(frame_count .EQ. 1)then
     num_comparison=natoma
     ALLOCATE(count_totals2(1:num_points))
     count_totals2(:)=0
     OPEN(999,FILE='hb_count_matrix.dat')
     OPEN(998,FILE='hb_count_totals.dat')
     OPEN(125,FILE='hb_avg.dat')
  endif

  curr_count=0

!--------------------------------!

!~~~~~~~~~~~~~Serine~~~~~~~~~~~~~!
  if(NatomB .GT. 0)then
     write(*,*)"Loop1"
     num_protons=1
     do k=1,natoma
        kk=lista(k)
        do j=1,natomb
           jj=listb(j)
           if(kk .NE. jj)then
              if(type_array(jj)==1)then
                 curr_dist=0.0
                 curr_dist=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                 if(curr_dist .LE. 3.5)then
                    !Proton Loop
                    do q=1,num_protons
                       jj=listb(j+q)
                       dist_a=0.0
                       dist_a=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                       if(dist_a .LE. 2.45)then
                          !Acceptor
                          if((X(kk)<=minnx).AND.(X(kk)>=maxxx).AND.(Y(kk)>=minny).AND.(Y(kk)<=maxxy).AND.(Z(kk)>=minnz).AND.(Z(kk)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(kk))
                          yy=floor(Y(kk))
                          zz=floor(Z(kk))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                          !Donor
                          if((X(jj)>=minnx).AND.(X(jj)<=maxxx).AND.(Y(jj)>=minny).AND.(Y(jj)<=maxxy).AND.(Z(jj)>=minnz).AND.(Z(jj)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(jj))
                          yy=floor(Y(jj))
                          zz=floor(Z(jj))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                       endif
                    enddo
                 endif
              endif
           endif
        enddo
     enddo   
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~Threonine~~~~~~~~~~~!
  if(NatomC .GT. 0)then
     write(*,*)"Loop2"
     num_protons=1
     do k=1,natoma
        kk=lista(k)
        do j=1,natomc
           jj=listc(j)
           if(kk .NE. jj)then
              if(type_array(jj)==1)then
                 curr_dist=0.0
                 curr_dist=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                 if(curr_dist .LE. 3.5)then
                    !Proton Loop
                    do q=1,num_protons
                       jj=listc(j+q)
                       dist_a=0.0
                       dist_a=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                       if(dist_a .LE. 2.45)then
                          !Acceptor
                          if((X(kk)>=minnx).AND.(X(kk)<=maxxx).AND.(Y(kk)>=minny).AND.(Y(kk)<=maxxy).AND.(Z(kk)>=minnz).AND.(Z(kk)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(kk))
                          yy=floor(Y(kk))
                          zz=floor(Z(kk))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                          !Donor
                          if((X(jj)>=minnx).AND.(X(jj)<=maxxx).AND.(Y(jj)>=minny).AND.(Y(jj)<=maxxy).AND.(Z(jj)>=minnz).AND.(Z(jj)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(jj))
                          yy=floor(Y(jj))
                          zz=floor(Z(jj))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                       endif
                    enddo
                 endif
              endif
           endif
        enddo
     enddo
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~Tyrosine~~~~~~~~~~~~!
 if(NatomD .GT. 0)then
     write(*,*)"Loop3"
     num_protons=1
     do k=1,natoma
        kk=lista(k)
        do j=1,natomd
           jj=listd(j)
           if(kk .NE. jj)then
              if(type_array(jj)==1)then
                 curr_dist=0.0
                 curr_dist=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                 if(curr_dist .LE. 3.5)then
                    !Proton Loop
                    do q=1,num_protons
                       jj=listd(j+q)
                       dist_a=0.0
                       dist_a=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                       if(dist_a .LE. 2.45)then
                          !Acceptor
                          if((X(kk)>=minnx).AND.(X(kk)<=maxxx).AND.(Y(kk)>=minny).AND.(Y(kk)<=maxxy).AND.(Z(kk)>=minnz).AND.(Z(kk)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(kk))
                          yy=floor(Y(kk))
                          zz=floor(Z(kk))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                          !Donor
                          if((X(jj)>=minnx).AND.(X(jj)<=maxxx).AND.(Y(jj)>=minny).AND.(Y(jj)<=maxxy).AND.(Z(jj)>=minnz).AND.(Z(jj)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(jj))
                          yy=floor(Y(jj))
                          zz=floor(Z(jj))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                       endif
                    enddo
                 endif
              endif
           endif
        enddo
     enddo
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~Tryptophan~~~~~~~~~~~~~~!
  if(NatomE .GT. 0)then
     write(*,*)"Loop4"
     num_protons=1
     do k=1,natoma
        kk=lista(k)
        do j=1,natome
           jj=liste(j)
           if(kk .NE. jj)then
              if(type_array(jj)==1)then
                 curr_dist=0.0
                 curr_dist=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                 if(curr_dist .LE. 3.5)then
                    !Proton Loop
                    do q=1,num_protons
                       jj=liste(j+q)
                       dist_a=0.0
                       dist_a=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                       if(dist_a .LE. 2.45)then
                          !Acceptor
                          if((X(kk)>=minnx).AND.(X(kk)<=maxxx).AND.(Y(kk)>=minny).AND.(Y(kk)<=maxxy).AND.(Z(kk)>=minnz).AND.(Z(kk)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(kk))
                          yy=floor(Y(kk))
                          zz=floor(Z(kk))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                          !Donor
                          if((X(jj)>=minnx).AND.(X(jj)<=maxxx).AND.(Y(jj)>=minny).AND.(Y(jj)<=maxxy).AND.(Z(jj)>=minnz).AND.(Z(jj)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(jj))
                          yy=floor(Y(jj))
                          zz=floor(Z(jj))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                       endif
                    enddo
                 endif
              endif
           endif
        enddo
     enddo
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~Arginine~~~~~~~~~~~~~!
  if(NatomF .GT. 0)then
     write(*,*)"Loop5"
     num_protons=1
     do k=1,natoma
        kk=lista(k)
        do j=1,natomf
           jj=listf(j)
           if(kk .NE. jj)then
              if(type_array(jj)==1)then
                 curr_dist=0.0
                 curr_dist=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                 if(curr_dist .LE. 3.5)then
                    !Proton Loop
                    do q=1,num_protons
                       jj=listf(j+q)
                       dist_a=0.0
                       dist_a=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                       if(dist_a .LE. 2.45)then
                          !Acceptor
                          if((X(kk)>=minnx).AND.(X(kk)<=maxxx).AND.(Y(kk)>=minny).AND.(Y(kk)<=maxxy).AND.(Z(kk)>=minnz).AND.(Z(kk)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(kk))
                          yy=floor(Y(kk))
                          zz=floor(Z(kk))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                          !Donor
                          if((X(jj)>=minnx).AND.(X(jj)<=maxxx).AND.(Y(jj)>=minny).AND.(Y(jj)<=maxxy).AND.(Z(jj)>=minnz).AND.(Z(jj)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(jj))
                          yy=floor(Y(jj))
                          zz=floor(Z(jj))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                       endif
                    enddo
                 endif
              endif
           endif
        enddo
     enddo
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~~HSD~~~~~~~~~~~~~~~~!
  if(NatomLL .GT. 0)then
     write(*,*)"Loop6"
     num_protons=1
     do k=1,natoma
        kk=lista(k)
        do j=1,natomll
           jj=listl(j)
           if(kk .NE. jj)then
              if(type_array(jj)==1)then
                 curr_dist=0.0
                 curr_dist=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                 if(curr_dist .LE. 3.5)then
                    !Proton Loop
                    do q=1,num_protons
                       jj=listl(j+q)
                       dist_a=0.0
                       dist_a=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                       if(dist_a .LE. 2.45)then
                          !Acceptor
                          if((X(kk)>=minnx).AND.(X(kk)<=maxxx).AND.(Y(kk)>=minny).AND.(Y(kk)<=maxxy).AND.(Z(kk)>=minnz).AND.(Z(kk)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(kk))
                          yy=floor(Y(kk))
                          zz=floor(Z(kk))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                          !Donor
                          if((X(jj)>=minnx).AND.(X(jj)<=maxxx).AND.(Y(jj)>=minny).AND.(Y(jj)<=maxxy).AND.(Z(jj)>=minnz).AND.(Z(jj)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(jj))
                          yy=floor(Y(jj))
                          zz=floor(Z(jj))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                       endif
                    enddo
                 endif
              endif
           endif
        enddo
     enddo
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~~HSE~~~~~~~~~~~~~~~~!
  if(NatomM .GT. 0)then
     write(*,*)"Loop7"
     num_protons=1
     do k=1,natoma
        kk=lista(k)
        do j=1,natomm
           jj=listm(j)
           if(kk .NE. jj)then
              if(type_array(jj)==1)then
                 curr_dist=0.0
                 curr_dist=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                 if(curr_dist .LE. 3.5)then
                    !Proton Loop
                    do q=1,num_protons
                       jj=listm(j+q)
                       dist_a=0.0
                       dist_a=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                       if(dist_a .LE. 2.45)then
                          !Acceptor
                          if((X(kk)>=minnx).AND.(X(kk)<=maxxx).AND.(Y(kk)>=minny).AND.(Y(kk)<=maxxy).AND.(Z(kk)>=minnz).AND.(Z(kk)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(kk))
                          yy=floor(Y(kk))
                          zz=floor(Z(kk))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                          !Donor
                          if((X(jj)>=minnx).AND.(X(jj)<=maxxx).AND.(Y(jj)>=minny).AND.(Y(jj)<=maxxy).AND.(Z(jj)>=minnz).AND.(Z(jj)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(jj))
                          yy=floor(Y(jj))
                          zz=floor(Z(jj))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                       endif
                    enddo
                 endif
              endif
           endif
        enddo
     enddo
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!
!~~~~~~~~~~~~~H2O~~~~~~~~~~~~~~~~!
  if(NatomG .GT. 0)then
     write(*,*)"Loop8"
     num_protons=2
     do k=1,natoma
        kk=lista(k)
        do j=1,natomg
           jj=listg(j)
           if(kk .NE. jj)then
              if(type_array(jj)==1)then
                 curr_dist=0.0
                 curr_dist=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                 if(curr_dist .LE. 3.5)then
                    !Proton Loop
                    do q=1,num_protons
                       jj=listg(j+q)
                       dist_a=0.0
                       dist_a=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                       if(dist_a .LE. 2.45)then
                          !Acceptor
                          if((X(kk)>=minnx).AND.(X(kk)<=maxxx).AND.(Y(kk)>=minny).AND.(Y(kk)<=maxxy).AND.(Z(kk)>=minnz).AND.(Z(kk)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(kk))
                          yy=floor(Y(kk))
                          zz=floor(Z(kk))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                          !Donor
                          if((X(jj)>=minnx).AND.(X(jj)<=maxxx).AND.(Y(jj)>=minny).AND.(Y(jj)<=maxxy).AND.(Z(jj)>=minnz).AND.(Z(jj)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(jj))
                          yy=floor(Y(jj))
                          zz=floor(Z(jj))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                       endif
                    enddo
                 endif
              endif
           endif
        enddo
     enddo
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~Asparagine~~~~~~~~~~~~!
  if(NatomH .GT. 0)then
     write(*,*)"Loop9"
     num_protons=2
     do k=1,natoma
        kk=lista(k)
        do j=1,natomh
           jj=listh(j)
           if(kk .NE. jj)then
              if(type_array(jj)==1)then
                 curr_dist=0.0
                 curr_dist=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                 if(curr_dist .LE. 3.5)then
                    !Proton Loop
                    do q=1,num_protons
                       jj=listh(j+q)
                       dist_a=0.0
                       dist_a=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                       if(dist_a .LE. 2.45)then
                          !Acceptor
                          if((X(kk)>=minnx).AND.(X(kk)<=maxxx).AND.(Y(kk)>=minny).AND.(Y(kk)<=maxxy).AND.(Z(kk)>=minnz).AND.(Z(kk)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(kk))
                          yy=floor(Y(kk))
                          zz=floor(Z(kk))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                          !Donor
                          if((X(jj)>=minnx).AND.(X(jj)<=maxxx).AND.(Y(jj)>=minny).AND.(Y(jj)<=maxxy).AND.(Z(jj)>=minnz).AND.(Z(jj)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(jj))
                          yy=floor(Y(jj))
                          zz=floor(Z(jj))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                       endif
                    enddo
                 endif
              endif
           endif
        enddo
     enddo
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~Glutamine~~~~~~~~~~~~~!
  if(NatomI .GT. 0)then
     write(*,*)"Loop10"
     num_protons=2
     do k=1,natoma
        kk=lista(k)
        do j=1,natomi
           jj=listi(j)
           if(kk .NE. jj)then
              if(type_array(jj)==1)then
                 curr_dist=0.0
                 curr_dist=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                 if(curr_dist .LE. 3.5)then
                    !Proton Loop
                    do q=1,num_protons
                       jj=listi(j+q)
                       dist_a=0.0
                       dist_a=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                       if(dist_a .LE. 2.45)then
                          !Acceptor
                          if((X(kk)>=minnx).AND.(X(kk)<=maxxx).AND.(Y(kk)>=minny).AND.(Y(kk)<=maxxy).AND.(Z(kk)>=minnz).AND.(Z(kk)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(kk))
                          yy=floor(Y(kk))
                          zz=floor(Z(kk))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                          !Donor
                          if((X(jj)>=minnx).AND.(X(jj)<=maxxx).AND.(Y(jj)>=minny).AND.(Y(jj)<=maxxy).AND.(Z(jj)>=minnz).AND.(Z(jj)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(jj))
                          yy=floor(Y(jj))
                          zz=floor(Z(jj))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                       endif
                    enddo
                 endif
              endif
           endif
        enddo
     enddo
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~Arginine Terminal NH~~~~~~~!
  if(NatomJ .GT. 0)then
     write(*,*)"Loop11"
     num_protons=2
     do k=1,natoma
        kk=lista(k)
        do j=1,natomj
           jj=listj(j)
           if(kk .NE. jj)then
              if(type_array(jj)==1)then
                 curr_dist=0.0
                 curr_dist=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                 if(curr_dist .LE. 3.5)then
                    !Proton Loop
                    do q=1,num_protons
                       jj=listj(j+q)
                       dist_a=0.0
                       dist_a=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                       if(dist_a .LE. 2.45)then
                          !Acceptor
                          if((X(kk)>=minnx).AND.(X(kk)<=maxxx).AND.(Y(kk)>=minny).AND.(Y(kk)<=maxxy).AND.(Z(kk)>=minnz).AND.(Z(kk)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(kk))
                          yy=floor(Y(kk))
                          zz=floor(Z(kk))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                          !Donor
                          if((X(jj)>=minnx).AND.(X(jj)<=maxxx).AND.(Y(jj)>=minny).AND.(Y(jj)<=maxxy).AND.(Z(jj)>=minnz).AND.(Z(jj)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(jj))
                          yy=floor(Y(jj))
                          zz=floor(Z(jj))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                       endif
                    enddo
                 endif
              endif
           endif
        enddo
     enddo
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~~~~Lysine~~~~~~~~~~~~~~!
  if(NatomK .GT. 0)then
     write(*,*)"Loop12"
     num_protons=3
     do k=1,natoma
        kk=lista(k)
        do j=1,natomk
           jj=listk(j)
           if(kk .NE. jj)then
              if(type_array(jj)==1)then
                 curr_dist=0.0
                 curr_dist=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                 if(curr_dist .LE. 3.5)then
                    !Proton Loop
                    do q=1,num_protons
                       jj=listk(j+q)
                       dist_a=0.0
                       dist_a=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                       if(dist_a .LE. 2.45)then
                          !Acceptor
                          if((X(kk)>=minnx).AND.(X(kk)<=maxxx).AND.(Y(kk)>=minny).AND.(Y(kk)<=maxxy).AND.(Z(kk)>=minnz).AND.(Z(kk)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(kk))
                          yy=floor(Y(kk))
                          zz=floor(Z(kk))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                          !Donor
                          if((X(jj)>=minnx).AND.(X(jj)<=maxxx).AND.(Y(jj)>=minny).AND.(Y(jj)<=maxxy).AND.(Z(jj)>=minnz).AND.(Z(jj)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(jj))
                          yy=floor(Y(jj))
                          zz=floor(Z(jj))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                       endif
                    enddo
                 endif
              endif
           endif
        enddo
     enddo
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

!~~~~~~~~~Backbone NH~~~~~~~~~~~~!
  if(NatomN .GT. 0)then
     write(*,*)"Loop13"
     num_protons=1
     do k=1,natoma
        kk=lista(k)
        do j=1,natomn
           jj=listn(j)
           if(kk .NE. jj)then
              if(type_array(jj)==1)then
                 curr_dist=0.0
                 curr_dist=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                 if(curr_dist .LE. 3.5)then
                    !Proton Loop
                    do q=1,num_protons
                       jj=listn(j+q)
                       dist_a=0.0
                       dist_a=sqrt(((X(kk)-X(jj))**2.0)+((Y(kk)-Y(jj))**2.0)+((Z(kk)-Z(jj))**2.0))
                       if(dist_a .LE. 2.45)then
                          !Acceptor
                          if((X(kk)>=minnx).AND.(X(kk)<=maxxx).AND.(Y(kk)>=minny).AND.(Y(kk)<=maxxy).AND.(Z(kk)>=minnz).AND.(Z(kk)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(kk))
                          yy=floor(Y(kk))
                          zz=floor(Z(kk))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                          !Donor
                          if((X(jj)>=minnx).AND.(X(jj)<=maxxx).AND.(Y(jj)>=minny).AND.(Y(jj)<=maxxy).AND.(Z(jj)>=minnz).AND.(Z(jj)<=maxxz))then
                              curr_count=curr_count+1
                          endif
                          xx=floor(X(jj))
                          yy=floor(Y(jj))
                          zz=floor(Z(jj))
                          if((xx>=minnx).AND.(xx<=maxxx).AND.(yy>=minny).AND.(yy<=maxxy).AND.(zz>=minnz).AND.(zz<=maxxz))then
                              do rx=xx-1,xx+1
                                 do ry=yy-1,yy+1
                                    do rz=zz-1,zz+1
                                       if((rx>=minnx).AND.(rx<=maxxx).AND.(ry>=minny).AND.(ry<=maxxy).AND.(rz>=minnz).AND.(rz<=maxxz))then
                                           n_of_grid=(rx-minnx)+((ry-minny)*sidex)+((rz-minnz)*sidex*sidey)+1
                                           if((n_of_grid>0) .AND. (n_of_grid<=num_points))then
                                               grid_array2(n_of_grid)=grid_array2(n_of_grid)+1.0
                                           endif
                                       endif
                                    enddo
                                 enddo
                              enddo
                          endif
                       endif
                    enddo
                 endif
              endif
           endif
        enddo
     enddo
  endif
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

!--------------------------------!

  !Write and Update HB Counts
  do xx=minnx,maxxx
     do yy=minny,maxxy
        do zz=minnz,maxxz
           n_of_grid=(xx-minnx)+((yy-minny)*sidex)+((zz-minnz)*sidex*sidey)+1
           count_totals2(n_of_grid)=count_totals2(n_of_grid)+grid_array2(n_of_grid)
           write(999,'(I8,2x,G21.14)'),frame_count,grid_array2(n_of_grid)
           call flush(999)
           if(mod(frame_count,10) .EQ. 0)then
              write(998,'(I8,2x,G21.14)'),frame_count,count_totals2(n_of_grid)
              call flush(998)
           endif
        enddo
     enddo
  enddo

 !Write Average
 write(125,'(I8,2x,G21.14)'),frame_count,((curr_count+0.0)/(num_comparison+0.0))
 call flush(125)

!--------------------------------!

 DEALLOCATE(grid_array2)

end subroutine


!------------------------------------------------!
subroutine INITIILZE_RADIUS_SELECTIONS()
!------------------------------------------------!
  use sa_analysis
  use psf
  use image
  !use consta
  use param
  
  implicit none

  integer :: i

  ALLOCATE(radius_array(1:natim))
  radius_array(:)=0.0

  do i=1,Natim
     radius_array(i)=(VDWR(ITC(IAC(i))))
  enddo

end subroutine


!------------------------------------------------!
subroutine DESELECT_RADIUS()
!------------------------------------------------!
 use sa_analysis

 implicit none

 DEALLOCATE (radius_array)

end subroutine


!------------------------------------------------!
subroutine COUNT_WATER_DENSITY()
!------------------------------------------------!
  use sa_analysis
  use coord
  use psf
  use image

  implicit none

  integer :: xx,yy,zz,n_of_grid
  real(chm_real) :: curr_count

  ALLOCATE(grid_array2(1:num_points))
  grid_array2(:)=0.0

  frame_count=frame_count+1
  write(*,*)"Processing Frame  ",frame_count

  if(frame_count .EQ. 1)then
     num_comparison=natoma
     ALLOCATE(count_totals2(1:num_points))
     count_totals2(:)=0.0
     OPEN(999,FILE='density_count_matrix.dat')
     OPEN(998,FILE='density_count_totals.dat')
     OPEN(125,FILE='density_avg.dat')
  endif

  curr_count=0.0

  call water_wrapper_2(frame_count,X,Y,Z,minnx,minny,minnz,maxxx,maxxy,maxxz,sidex,sidey,sidez,grid_array2,NatomA,ListA,natim,radius_array)

  !Write and Update Density
  do xx=minnx,maxxx
     do yy=minny,maxxy
        do zz=minnz,maxxz
           n_of_grid=(xx-minnx)+((yy-minny)*sidex)+((zz-minnz)*sidex*sidey)+1
           count_totals2(n_of_grid)=count_totals2(n_of_grid)+grid_array2(n_of_grid)
           curr_count=curr_count+grid_array2(n_of_grid)
           write(999,'(I8,2x,G21.14)'),frame_count,grid_array2(n_of_grid)
           call flush(999)
           if(mod(frame_count,10) .EQ. 0)then
              write(998,'(I8,2x,G21.14)'),frame_count,count_totals2(n_of_grid)
              call flush(998)
           endif
        enddo
     enddo
  enddo

  !Write Average
  write(125,'(I8,2x,G21.14)'),frame_count,(curr_count/(num_points+0.0))
  call flush(125)


  DEALLOCATE(grid_array2)

end subroutine

!------------------------------------------------!
subroutine COUNT_WATER_DENSITY_2()
!------------------------------------------------!
  use sa_analysis
  use coord
  use psf
  use image
  use consta
  use param

  implicit none

  real(chm_real) ::curr_dist,gaussian_density,atom_radius,curr_count

  integer :: xx,yy,zz,n_of_grid,k,kk,q,R

  ALLOCATE(grid_array2(1:num_points))
  grid_array2(:)=0.0

  frame_count=frame_count+1
  write(*,*)"Processing Frame  ",frame_count

  if(frame_count .EQ. 1)then
     num_comparison=natoma
     ALLOCATE(count_totals2(1:num_points))
     count_totals2(:)=0.0
     OPEN(999,FILE='density_count_matrix.dat')
     OPEN(998,FILE='density_count_totals.dat')
     OPEN(125,FILE='density_avg.dat')
  endif

  curr_count=0.0

  !Calculate Density
  do q=1,num_points
       zz=q/(sidex*sidey)
       R=modulo(q,(sidex*sidey))
       yy=R/sidex
       xx=modulo(R,sidex)
       xx=xx+minnx
       yy=yy+minny
       zz=zz+minnz
       do k=1,NatomA
          kk=ListA(k)
          curr_dist=SQRT(((X(kk)-(xx+0.0))**2.0)+((Y(kk)-(yy+0.0))**2.0)+((Z(kk)-(zz+0.0))**2.0))
          if(curr_dist .LE. 6.0)then
             atom_radius=((VDWR(ITC(IAC(kk))))/2.0)**2.0 !This is the Radius Squared Over 2... Xubin = r/2
             gaussian_density=((2.0*pi*atom_radius)**(-3.0/2.0))*(exp(((-1.0)*((curr_dist)**2.0))/((2.0)*(atom_radius))))
             n_of_grid=(xx-minnx)+((yy-minny)*sidex)+((zz-minnz)*sidex*sidey)+1
             grid_array2(n_of_grid)=grid_array2(n_of_grid)+gaussian_density
          endif
       enddo
  enddo

  !Write and Update Density
  do xx=minnx,maxxx
     do yy=minny,maxxy
        do zz=minnz,maxxz
           n_of_grid=(xx-minnx)+((yy-minny)*sidex)+((zz-minnz)*sidex*sidey)+1
           count_totals2(n_of_grid)=count_totals2(n_of_grid)+grid_array2(n_of_grid)
           curr_count=curr_count+grid_array2(n_of_grid)
           write(999,'(I8,2x,G21.14)'),frame_count,grid_array2(n_of_grid)
           call flush(999)
           if(mod(frame_count,10) .EQ. 0)then
              write(998,'(I8,2x,G21.14)'),frame_count,count_totals2(n_of_grid)
              call flush(998)
           endif
        enddo
     enddo
  enddo

  !Write Average
  write(125,'(I8,2x,G21.14)'),frame_count,(curr_count/(num_points+0.0))
  call flush(125)

  DEALLOCATE(grid_array2)

end subroutine
